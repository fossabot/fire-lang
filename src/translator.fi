fn translate(fpath: str, filename: str, code: str, toks: List[Token], main: bool) -> str {
    let indent = 0;
    let ln_no = 0;
    let out = ("") if (main) else (" " * indent);
    let struct_ = bool(0);
    let last: List[Token] = [];
    let opt: List[str] = [];
    let impl_ = 0;
    let implname = "";
    let implout = "";
    let implskip = bool(0);


    let pykeywords = (
        "False","class","finally","is",
        "lambda","try","True","def","from",
        "nonlocal","and","del","global",
        "not","with","as","or","yield",
        "assert","else","import","pass",
        "except","in","raise"
    );

    let keywords = dict({
        "if": "if",
        "fn": "def",
        "return": "return",
        "while": "while",
        "else": "else",
        "continue": "continue",
        "break": "break",
        "in": " in",
        "for": "for",
        "struct": "class"
    });

    for i, tok in enumerate(toks) {
        if tok.type == "whitespace" {
            continue;
        }
        
        if tok.type == "newline" {
            out += ("\n##{}:{}~ ".format(filename, ln_no + 1)
                + code.splitlines()[ln_no].strip()
                + "\n" + " " * indent);
            ln_no += 1;
            continue;
        }

        if implskip && tok.val == "{" {
            implskip = bool(0);
            indent += 1;
            out += "\n" + " " * indent;
            continue;
        }

        if implskip {
            continue;
        }

        last += [tok];

        if tok.type == "ID" {
            if tok.val == "impl" {
                impl_ += 1;
                implout = out;
                implskip = bool(1);
                let j = 0;
                while toks[i+j].val.strip() != "" {
                    j += 1;
                }
                implname = toks[i+j+1].val;
                out = "";
                continue;
            }
            else if tok.val in keywords {
                if tok.val == "struct" {
                    struct_ = bool(1);
                    out += "\n" + " " * indent;
                }
                out += keywords[tok.val] + " ";
            }
            else if tok.val in pykeywords {
                out += "_" + tok.val;
            }
            else {
                if tok.val in opt {
                    out += "__" + tok.val;
                }
                else {
                    out += tok.val;
                }
            }
        }
        else if tok.type == "AND-OR" {
            if tok.val == "&&" {
                out += " and ";
            }
            else if tok.val == "||" {
                out += " or ";
            }
        }
        else if tok.type == "ELSE-IF" {
            out += "elif ";
            
            "TODO: Include, Import";
        }
        else if tok.type == "RANGE" {
            if tok.val.startswith("(") && tok.val.endswith("(") {
                tok.val = tok.val[1:-1];
            }
            out += ("list(range{})".format
                (tuple(int(e) for (e) in (tok.val.split("." + ".")))));
        }
        else if tok.type == "DICT" {
            if tok.val.endswith("({") {
                out += "{";
            }
            else if tok.val == ")}" {
                out += "}";
            }
        }
        else if tok.type == "," {
            if struct_ {
                out += "\n" + " " * indent;
            }
            else {
                out += ",";
            }
        }
        else if tok.type == ";" {
            if struct_ {
                out += "!@#$";
            }
            else {
                out += ";pass\n" + " " * indent;
            }
        }
        else if tok.type == "{" {
            indent += 1;
            out += ":\n" + " " * indent + "pass";
            out += "\n" + " " * indent;

            if len(last) >= 10 {
                let llt = [str(e) for e in last][-10:];
                let fname = llt.pop(1);
                llt.pop(2);
                if llt == ["fn", "(", ":", "int", ")", "->", "int", "{"] {
                    opt += [fname];
                    out = "__{}__:Dict[int,int]=dict()\n".format(fname) + out;
                    out += "if i in __{}__: return __{}__[i]".format(fname, fname);
                    out += "\n" + " " * indent;
                    let lx = "def __{}(i: int) -> int:\n".format(fname);
                    lx += " tmp = {}(i)\n".format(fname);
                    lx += " {}__[i] = tmp\n".format(fname);
                    lx += " return tmp\n";
                    out = lx + "\n" + out;
                }
            }
            if impl_ >= 1 {
                impl_ += 1;
            }
            if struct_ {
                out += "def __str__(self):";
                out += "\n" + " " * (indent + 1);
                out += "ret: str = self.__class__.__name__ + \" { \"";
                out += "\n" + " " * (indent + 1);
                out += "for e in dir(self):";
                out += "\n" + " " * (indent + 2);
                out += "if not e.startswith(\"_\"):";
                out += "\n" + " " * (indent + 3);
                out += "if type(eval(\"self.\"+e)) == str:";
                out += "\n" + " " * (indent + 4);
                out += "ret += f\"{e} = {str(eval(\\\"self.\\\"+e).encode())[1:]}, \"";
                out += "\n" + " " * (indent + 3);
                out += "else: ret += f\"{e} = {str(eval(\\\"self.\\\"+e))}, \"";
                out += "\n" + " " * (indent + 1);
                out += "return ret[:-2] + \" }\"";
                out += "\n" + " " * indent;
            }
        }
        else if tok.type == "}" {
            if impl_ >= 1 {
                impl_ -= 1;
            }
            if impl_ == 0 {
                let implcx = "class {}:".format(implname);
                if implcx in implout {
                    let pos = implout.index(implcx) + len(implcx);
                    out = implout[:pos] + "\n" + out + "\n" + implout[pos:];
                }
            }
            if struct_ {
                struct_ = bool(0);
            }
            indent -= 1;
            out += "\n" + " " * indent;
        }
        else if tok.val == "::" {
            out += ".";
        }
        else {
            out += tok.val;
        }
    }

    if main {
        out += ("\nif __name__=='__main__':"
            "\n from sys import argv"
            "\n main(len(argv),argv)"
            "\n del argv")
    }

    let x = out.splitlines();
    let y = "";
    
    for l in x {
        if l.strip() != "" {
            y += l + "\n"
        }
    }

    out = y;

    while "\n\n" in out {
        out = out.replace("\n\n", "\n");
    }

    return out;
}
